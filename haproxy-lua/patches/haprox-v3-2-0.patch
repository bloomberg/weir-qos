From 77084d20e0a882dc154c696094847372ee8d747f Mon Sep 17 00:00:00 2001
From: Aby Okhovat <aokhovat@bloomberg.net>
Date: Tue, 4 Nov 2025 18:12:55 +0000
Subject: [PATCH] Describe your changes here

---
 Makefile   |   2 +
 src/hlua.c | 133 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 135 insertions(+)

diff --git a/Makefile b/Makefile
index 1959ac479..e698078a1 100644
--- a/Makefile
+++ b/Makefile
@@ -994,6 +994,8 @@ OBJS += src/mux_h2.o src/mux_h1.o src/mux_fcgi.o src/log.o		\
         src/hpack-huff.o src/hpack-enc.o src/ebtree.o src/hash.o	\
         src/version.o

+OBJS += src/flt_weir.o src/rate_limit.o
+
 ifneq ($(TRACE),)
   OBJS += src/calltrace.o
 endif
diff --git a/src/hlua.c b/src/hlua.c
index 9699936e8..8fdc92b57 100644
--- a/src/hlua.c
+++ b/src/hlua.c
@@ -69,6 +69,7 @@
 #include <haproxy/event_hdl.h>
 #include <haproxy/check.h>
 #include <haproxy/mailers.h>
+#include <haproxy/rate_limit.h>

 /* Global LUA flags */

@@ -2230,6 +2231,103 @@ __LJMP static int hlua_done(lua_State *L)
 	return 0;
 }

+/* Handle receipt of a new limit-share update, instructing the local instance on what limit to apply to a given key.
+ * In lua code, this is called as ingest_weir_limit_share(timestamp_seconds, key, instance, "up"|"down", limit)
+ * Example: ingest_weir_limit_share("1716197521", "myaccesskey", "1f2e3d4c", "down", "4096")
+ */
+int weir_ingest_limit_share_update(uint64_t, const char*, const char*, const char*, uint64_t);
+__LJMP static int hlua_ingest_weir_limit_share_update(lua_State *L)
+{
+	const char* timestamp_str;
+	const char *user_key;
+	const char *instance_id;
+	const char *direction;
+	const char* limit_str;
+	uint64_t timestamp;
+	uint64_t limit;
+	int success;
+
+	timestamp_str = MAY_LJMP(luaL_checkstring(L, 1));
+	user_key = MAY_LJMP(luaL_checkstring(L, 2));
+	instance_id = MAY_LJMP(luaL_checkstring(L, 3));
+	direction = MAY_LJMP(luaL_checkstring(L, 4));
+	limit_str = MAY_LJMP(luaL_checkstring(L, 5));
+	timestamp = strtoull(timestamp_str, NULL, 10);
+	limit = strtoull(limit_str, NULL, 10);
+
+	success = weir_ingest_limit_share_update(timestamp, user_key, instance_id, direction, limit);
+	lua_pushboolean(L, success);
+	return 1;
+}
+
+/* This function throttle the speed for a key.
+ *  In lua code, this is called as throttle_key_speed(key,"upload"|"download",epoch_sec, diff_ratio)
+ *  Example: throttle_key_speed("user_AKIAIOSFODNN7EXAMPLE","upload","1621317031", "1.2")
+ */
+__LJMP static int hlua_throttle_key_speed(lua_State *L)
+{
+	const char *key;
+	const char *put_get;
+	const char *epoch_us;
+	const char *diff_ratio;
+	float diff_ratio_f;
+	uint64_t epoch_us_n;
+
+	key = MAY_LJMP(luaL_checkstring(L, 1));
+	put_get = MAY_LJMP(luaL_checkstring(L, 2));
+	epoch_us = MAY_LJMP(luaL_checkstring(L, 3));
+	diff_ratio = MAY_LJMP(luaL_checkstring(L, 4));
+	diff_ratio_f = atof(diff_ratio);
+	epoch_us_n = strtoull(epoch_us, NULL, 0);
+
+	if (strcmp(put_get, "upload") == 0){
+		set_throttle_epoch_us(key, epoch_us_n, RL_UPLOAD, diff_ratio_f);
+		lua_pushboolean(L, 1);
+		return 1;
+	}
+	if (strcmp(put_get, "download") == 0){
+		set_throttle_epoch_us(key, epoch_us_n, RL_DOWNLOAD, diff_ratio_f);
+		lua_pushboolean(L, 1);
+		return 1;
+	}
+
+	lua_pushboolean(L, 0);
+
+	return 1;
+}
+
+/* This function set the jitter range for data segments transfer post bandwidth throttling. */
+__LJMP static int hlua_set_jitter_range(lua_State *L)
+{
+	uint32_t jitter_range = MAY_LJMP(luaL_checkinteger(L, 1));
+	set_jitter_range(jitter_range);
+	lua_pushboolean(L, 1);
+	return 1;
+}
+
+/* debug help function, print out speed limit table.
+*/
+__LJMP static int hlua_printout_speed_table(lua_State *L)
+{
+
+	const char* put_get = MAY_LJMP(luaL_checkstring(L, 1));
+
+	if (strcmp(put_get, "upload") == 0){
+		print_out_key_speed_table(RL_UPLOAD);
+		lua_pushboolean(L, 1);
+		return 1;
+	}
+	if (strcmp(put_get, "download") == 0){
+		print_out_key_speed_table(RL_DOWNLOAD);
+		lua_pushboolean(L, 1);
+		return 1;
+	}
+
+	lua_pushboolean(L, 0);
+
+	return 1;
+}
+
 /* This function is an LUA binding. It provides a function
  * for deleting ACL from a referenced ACL file.
  */
@@ -6889,6 +6987,23 @@ static int hlua_http_req_set_uri(lua_State *L)
 	return 1;
 }

+/* This function map a ip/port pair to a key.
+*  The key will be used for speed limiting.
+*  Lua code looks like txn.http:req_set_ip_port_key(txn.f:src(), txn.f:src_port(), speed_access_key)
+*/
+static int hlua_http_req_set_ip_port_key(lua_State *L)
+{
+    struct hlua_txn *htxn = MAY_LJMP(hlua_checkhttp(L, 1));
+	if (htxn != NULL) {
+		const char* ip = MAY_LJMP(luaL_checkstring(L, 2));
+		const char *port= MAY_LJMP(luaL_checkstring(L, 3));
+		const char *key= MAY_LJMP(luaL_checkstring(L, 4));
+		set_ip_port_key(ip, port, key);
+	    return 1;
+	}
+	return 0;
+}
+
 /* This function set the response code & optionally reason. */
 static int hlua_http_res_set_status(lua_State *L)
 {
@@ -6904,6 +7019,18 @@ static int hlua_http_res_set_status(lua_State *L)
 	return 0;
 }

+static int hlua_http_res_get_status(lua_State *L)
+{
+    struct hlua_txn *htxn = MAY_LJMP(hlua_checkhttp(L, 1));
+    struct http_txn *txn = htxn->s->txn;
+    if (txn) {
+        lua_pushinteger(L, txn->status);
+        return 1;
+    }
+    return 0;
+}
+
+
 /*
  *
  *
@@ -14160,6 +14287,10 @@ lua_State *hlua_init_state(int thread_num)
 	hlua_class_function(L, "Alert", hlua_log_alert);
 	hlua_class_function(L, "done", hlua_done);
 	hlua_class_function(L, "disable_legacy_mailers", hlua_disable_legacy_mailers);
+	hlua_class_function(L, "ingest_weir_limit_share_update", hlua_ingest_weir_limit_share_update);
+	hlua_class_function(L, "throttle_key_speed", hlua_throttle_key_speed);
+	hlua_class_function(L, "printout_speed_table", hlua_printout_speed_table);
+	hlua_class_function(L, "set_jitter_range", hlua_set_jitter_range);
 	hlua_fcn_reg_core_fcn(L);

 	lua_setglobal(L, "core");
@@ -14408,6 +14539,7 @@ lua_State *hlua_init_state(int thread_num)
 	hlua_class_function(L, "req_set_path",   hlua_http_req_set_path);
 	hlua_class_function(L, "req_set_query",  hlua_http_req_set_query);
 	hlua_class_function(L, "req_set_uri",    hlua_http_req_set_uri);
+	hlua_class_function(L, "req_set_ip_port_key", hlua_http_req_set_ip_port_key);

 	hlua_class_function(L, "res_get_headers",hlua_http_res_get_headers);
 	hlua_class_function(L, "res_del_header", hlua_http_res_del_hdr);
@@ -14416,6 +14548,7 @@ lua_State *hlua_init_state(int thread_num)
 	hlua_class_function(L, "res_add_header", hlua_http_res_add_hdr);
 	hlua_class_function(L, "res_set_header", hlua_http_res_set_hdr);
 	hlua_class_function(L, "res_set_status", hlua_http_res_set_status);
+	hlua_class_function(L, "res_get_status", hlua_http_res_get_status);

 	lua_rawset(L, -3);

--
2.44.4

