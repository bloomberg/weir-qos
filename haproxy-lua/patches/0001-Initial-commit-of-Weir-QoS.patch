From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jacques Heunis <jheunis@bloomberg.net>
Date: Mon, 28 Apr 2025 11:43:51 +0100
Subject: [PATCH] Initial commit of Weir QoS

---
 Makefile       |  1 +
 src/freq_ctr.c | 13 +++++++++++++
 src/hlua.c     | 30 ++++++++++++++++++++++++++++++
 3 files changed, 44 insertions(+)

diff --git a/Makefile b/Makefile
index 11096c223..82fcf529d 100644
--- a/Makefile
+++ b/Makefile
@@ -940,6 +940,7 @@ OBJS += src/mux_h2.o src/mux_fcgi.o src/mux_h1.o src/tcpcheck.o               \
         src/dynbuf.o src/wdt.o src/pipe.o src/init.o src/http_acl.o           \
         src/hpack-huff.o src/hpack-enc.o src/dict.o src/freq_ctr.o            \
         src/ebtree.o src/hash.o src/dgram.o src/version.o
+OBJS += src/flt_weir.o
 
 ifneq ($(TRACE),)
   OBJS += src/calltrace.o
diff --git a/src/freq_ctr.c b/src/freq_ctr.c
index 9b001e326..58eb4b749 100644
--- a/src/freq_ctr.c
+++ b/src/freq_ctr.c
@@ -207,6 +207,19 @@ int freq_ctr_overshoot_period(const struct freq_ctr *ctr, uint period, uint freq
 		return 0;
 	}
 
+	if (unlikely(elapsed > 2 * period)) {
+		/* The counter was last used further into the past than the previous period,
+		 * so by definition there is no overshoot.
+		 * We need to check this because otherwise if you use a counter, wait a long time,
+		 * and then try to use the counter again, this 32-bit division below will overflow
+		 * and we'll erroneously return a very large overshoot.
+		 * For example if period=2^10 (~1s) and freq=2^23 (8mb if we're counting bandwidth)
+		 * and if we note that INT_MAX~=2^31 then we'll overflow if
+		 * `elapsed > (period*INT_MAX)/freq`, or with actual values:
+		 * `elapsed > 2^18 which is a little over 4 minutes */
+		return 0;
+	}
+
 	return curr - div64_32((uint64_t)elapsed * freq, period);
 }
 
diff --git a/src/hlua.c b/src/hlua.c
index 742c82448..28c0b384d 100644
--- a/src/hlua.c
+++ b/src/hlua.c
@@ -1862,6 +1862,35 @@ __LJMP static int hlua_done(lua_State *L)
 	return 0;
 }
 
+/* Handle receipt of a new limit-share update, instructing the local instance on what limit to apply to a given key.
+ * In lua code, this is called as ingest_weir_limit_share(timestamp_seconds, key, instance, "up"|"down", limit)
+ * Example: ingest_weir_limit_share("1716197521", "myaccesskey", "1f2e3d4c", "down", "4096")
+ */
+int weir_ingest_limit_share_update(uint64_t, const char*, const char*, const char*, uint64_t);
+__LJMP static int hlua_ingest_weir_limit_share_update(lua_State *L)
+{
+	const char* timestamp_str;
+	const char *user_key;
+	const char *instance_id;
+	const char *direction;
+	const char* limit_str;
+	uint64_t timestamp;
+	uint64_t limit;
+	int success;
+
+	timestamp_str = MAY_LJMP(luaL_checkstring(L, 1));
+	user_key = MAY_LJMP(luaL_checkstring(L, 2));
+	instance_id = MAY_LJMP(luaL_checkstring(L, 3));
+	direction = MAY_LJMP(luaL_checkstring(L, 4));
+	limit_str = MAY_LJMP(luaL_checkstring(L, 5));
+	timestamp = strtoull(timestamp_str, NULL, 10);
+	limit = strtoull(limit_str, NULL, 10);
+
+	success = weir_ingest_limit_share_update(timestamp, user_key, instance_id, direction, limit);
+	lua_pushboolean(L, success);
+	return 1;
+}
+
 /* This function is an LUA binding. It provides a function
  * for deleting ACL from a referenced ACL file.
  */
@@ -13212,6 +13241,7 @@ lua_State *hlua_init_state(int thread_num)
 	hlua_class_function(L, "Alert", hlua_log_alert);
 	hlua_class_function(L, "done", hlua_done);
 	hlua_class_function(L, "disable_legacy_mailers", hlua_disable_legacy_mailers);
+	hlua_class_function(L, "ingest_weir_limit_share_update", hlua_ingest_weir_limit_share_update);
 	hlua_fcn_reg_core_fcn(L);
 
 	lua_setglobal(L, "core");
-- 
2.43.0

